#!/usr/bin/perl
use warnings;
use strict;

# Print list of modules which are needed for building of
# a given module or a program.
#
# Usage:
#   get_deps [-M|-L|-H] <lib directory> <modules or source files> ...
#
# Options:
#   -M -- find module dependencies
#   -L -- find library dependencies
#   -H -- find h-file dependencies and print as Makefile rules
#
#

# read options
my $mode = 'M';
while ($#ARGV>=0 && $ARGV[0] =~ "^-(.)(.*)") {
  shift @ARGV;
  $2 eq '' || warn "Unknown option: $ARGV[0]";
  next if $1 eq '-';

  if ($1 eq 'M') { $mode = 'M'; next; }
  if ($1 eq 'L') { $mode = 'L'; next; }
  if ($1 eq 'H') { $mode = 'H'; next; }

  warn "Unknown option: $ARGV[0]";
}

my $mod_dir = shift @ARGV || '.';
my @targets = @ARGV;

$#targets>=0 or
   die "Usage: get_deps [-M|-L|-H] <lib directory> <modules or source files> ...\n";

######################################################################
# read all variables from a module Makefile
sub read_make ($) {
  my $fname = shift;
  my %info;
  open F, $fname or die "can't read $fname file: $fname: $!";
  while (my $line = <F>){
    next unless $line =~ /^\s*([A-Za-z0-9_]+)\s*:?=\s*(.*)/;
    my $key = $1;
    $line = $2;
    # join lines with \ at the end, remove extra spaces
    $line .= <F> while $line =~ s/\\$//;
    $line =~ s/\s+/ /g;
    $info{$key} = $line;
  }
  close F;
  return %info;
}

# Read files, extract h-dependencies.
# mode 0: Read only #include "<name>/<file>" records
#         return non-recursive module set
# mode 1: Recursively find all "<name>/<file>"
#         and "<file>" h-dependensies

sub get_hdeps {
  my $dir = shift;
  my $files = shift;
  my $mode = shift || 0;
  my %deps;
  foreach my $f (@{$files}) {
    my $ff;
    unless(open $ff, "$dir/$f"){
      warn "can't open $dir/$f: $!";
      next;
    }
    while (my $l=<$ff>) {
      next unless $l=~/^#/;

      if ($l=~m|^#include\s+"([^"/]+)/([^"/]+)"|) {
        die "Can't find file \"$1/$2\" included in \"$f\"\n"
          unless -f "$mod_dir/$1/$2";
        if ($mode == 0) {
          $deps{"$1"} = 1;
        }
        else {
          my $file = "$mod_dir/$1/$2";
          $deps{$file} = 1;
          my %rec = get_hdeps("$mod_dir/$1", [$2], $mode);
          %deps = (%deps, %rec);
        }
      }

      if ($l=~m|^#include\s+"([^"/]+)"|) {
        die "Can't find file \"$1\" included in \"$f\"\n"
          unless -f "$dir/$1";
        if ($mode!=0){
          my $file = "$dir/$1";
          $deps{$file} = 1;
          my %rec = get_hdeps($dir, [$1], $mode);
          %deps = (%deps, %rec);
        }
      }
    }
    close F;
  }

  return %deps;
}

# recurcively go through all modules, collect their module dependencies
sub add_mod_dep {
  my $mods = shift;
  my $mod = shift;
  my $skip = shift || 0;
  my %info = read_make "$mod_dir/$mod/Makefile";
  my @files = split /\s+/, ($info{MOD_SOURCES}||'')." ".($info{MOD_HEADERS}||'');
  my %mdeps = get_hdeps("$mod_dir/$mod", \@files);
  $mods->{$mod} = [keys %mdeps] unless $skip || exists($mods->{$mod});
  add_mod_dep($mods, $_) foreach (keys %mdeps);
}

# build an ordered dependencie list
sub optimize_deps {
  my $mods = shift;
  my @ret;
  while (keys %{$mods} >0) {
    # find module with no deps
    my $m0 = '';
    foreach my $m (keys %{$mods}) {
      next unless $#{$mods->{$m}}==-1;
      $m0 = $m;
      last;
    }
    $m0 ne '' or die "Dependency calculation faild: no independent modules";
    # add it to build list, remove from dep list
    push @ret, $m0;
    delete $mods->{$m0};
    foreach my $m (keys %{$mods}) {
      my @ii = grep { ${$mods->{$m}}[$_] eq $m0 } 0..$#{$mods->{$m}};
      splice(@{$mods->{$m}}, $_, 1) foreach (@ii);
    }
  }
  return @ret;
}

# read library deps for a given Makefile.
sub get_lib_dep {
  my $libs = shift;
  my $mfile = shift;
  my %info = read_make $mfile;
  my @libs = split /\s+/, ($info{PKG_CONFIG}||'');
  $libs->{$_} = 1 foreach @libs;
}

############
############
## Main

if ($mode eq 'M' || $mode eq 'L'){

  # find modue dependecy structure: mod1->[mod2,mod3...]
  my %mods;
  foreach my $target (@targets) {
    if (-d "$mod_dir/$target") {
      add_mod_dep(\%mods, $target, 1);
    }
    elsif (-f $target) {
      my %mdeps = get_hdeps(".", [$target]);
      add_mod_dep(\%mods, $_) foreach (keys %mdeps);
    }
    else {
      warn "No file or directory: $target\n";
    }
  }

  # optimize dependencies, get list of modules in the correct order.
  my @list = optimize_deps(\%mods);

  # -M mode: printing modules
  if ($mode eq 'M') {
    print "$_\n" foreach (@list);
    exit 0;
  }

  # -L mode: print list of libraries for all these modules.
  if ($mode eq 'L') {
    my %libs;
    get_lib_dep(\%libs, "$mod_dir/$_/Makefile") foreach (@list);
    print "$_\n" foreach (keys %libs);
    exit 0;
  }
}

# -H mode: recursive h-dependensies for all files/modules
if ($mode eq 'H') {

  # find all c-files
  my @files;
  foreach my $target (@targets) {
    my %mods;
    if (-d "$mod_dir/$target") {
      my %info = read_make "$mod_dir/$target/Makefile";
      push @files, "$mod_dir/$target/$_"
        foreach(split /\s+/, ($info{MOD_SOURCES}||''));
    }
    elsif (-f $target) {
      push(@files, $target);
    }
    else {
      warn "No file or directory: $target\n";
    }
  }

  print "# This file is generated by get_deps program\n\n";

  # for each file find dependencies recursively
  foreach my $file (@files) {
    my $dir = ".";
    if ($file =~ m|(.*)/(.*)|){
      $dir = $1; $file = $2;
    }
    my %deps = get_hdeps($dir, [$file], 1);
    $file =~ s/(.cpp|.c)$/.o/;
    print "$file: ", join(" ", keys %deps), "\n\n";
  }
}


